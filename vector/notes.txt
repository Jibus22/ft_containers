# Notes & recherches ft_containers

### Recherches sur le comportement de vector.capacity()

nb push		  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
______________|___|___|___|___|___|___|___|___|___|___|____|____|____|____|____|
vector (0) -> | 0 | 1 | 2 | 4 | 4 | 8 | 8 | 8 | 8 | 16| 16 | 16 | 16 | 16 | 16 |
______________|___|___|___|___|___|___|___|___|___|___|____|____|____|____|____|
vector (10) ->| 10| 20| 20| 20| 20| 20| 20| 20| 20| 20| 20 | 40 | 40 | 40 | 40 |


nb push		  | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 |
______________|____|____|____|____|____|____|____|____|____|____|____|____|____|
vector (0) -> | 16 | 16 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 |
______________|____|____|____|____|____|____|____|____|____|____|____|____|____|
vector (10) ->| 40 | 40 | 40 | 40 | 40 | 20 | 40 | 40 | 40 | 40 | 40 | 40 | 40 |


nb push		  | 31 | 33 | 65 | 71 | 129| 151| 257| 311| 513| 631|1025|1271|2049|
______________|____|____|____|____|____|____|____|____|____|____|____|____|____|
vector (0) -> | 32 | 64 | 128| 128| 256| 256| 512| 512|1024|1024|2048|2048|4096|
______________|____|____|____|____|____|____|____|____|____|____|____|____|____|
vector (10) ->| 80 | 80 | 80 | 160| 160| 320| 320| 640| 640|1280|1280|2560|2560|

--

- observation : la capacité s'adapte pour grandir lors de push successifs, de
  manière qui semblerait logarithmique: pour n éléments atteints, on réserve
  y = 2n. une fois que y est atteint, on réserve w = 2y, et ainsi de suite.

- En revanche, imaginons que nous pushons 2000 éléments sur le vector et que
  nous en popions 1000, la capacité atteint d'abord 2048, puis reste à 2048
  après les pop.

--
### Recherches sur l'iterateur

- Si on récupère l'itérateur d'un vecteur<int> vide, via begin() ou end(),
  et qu'on le déréference, ça segfault.

- Si on fait pareil avec un vecteur avec un (ou plus) élément, l'iterateur
  déréférencé begin donne la valeur en question, end() donne '0'.

- Si on push (ex:21) puis pop, l'it de début donne 21, et le end aussi.

- Si on pop un vecteur vide ça segfault, si on pop un vecteur qui a été déja
  push & pop, ça bloque le processus (& cpu à 100% d'usage).

- Interprétation : à la construction, aucun headroom n'est reservé
  (end segfault) mais une fois qu'une valeur est pushé, le headroom apparait.
  Si une valeur est pop, le pointeur end headroom se décrémente sur l'ancienne
  adresse, qui n'a pas été memset à 0 et donc affiche toujours l'ancienne
  valeur.
  Le pointeur begin ne bouge pas et pointe toujours sur l'adresse du 1er
  élément. Si celui-ci est pop, cette adresse devient finalement l'adresse du
  headroom.
